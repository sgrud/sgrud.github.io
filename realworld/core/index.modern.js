import t from"@babel/runtime/helpers/extends";import{Http as e,Provider as s,assign as i,Factor as r,Target as o,Transit as a}from"@sgrud/core";import{from as n,first as p,map as l,switchMap as c,race as u,timer as d,forkJoin as h,delay as m,finalize as g}from"rxjs";import{__decorate as f}from"tslib";import{Stateful as v,Store as y,StateHandler as $}from"@sgrud/state";var w,b;let U=(b=w=class extends y{constructor(...t){super(...t),this.apiUrl=void 0}},w.handle="io.github.sgrud.state.config",w);U=b=f([v(b.handle,{apiUrl:"https://api.realworld.io/api"})],U);class S{static get apiUrl(){return n(new U).pipe(p(),l(({apiUrl:t})=>t))}static readArticles({author:s,favorited:i,limit:r=10,offset:o=0,path:a,tag:n}={}){return this.apiUrl.pipe(c(p=>e.request({queryParams:t({},s&&{author:s},i&&{favorited:i},r&&{limit:r},o&&{offset:o},n&&{tag:n}),url:`${p}/articles`+(a?`/${a}`:"")})),l(({response:e})=>t({},e,{author:s,favorited:i,limit:r,offset:o,path:a,tag:n})))}static readArticle(t){return this.apiUrl.pipe(l(e=>`${e}/articles/${t}`),c(t=>e.get(t)),l(({response:t})=>t.article))}static readComments(t){return this.apiUrl.pipe(l(e=>`${e}/articles/${t}/comments`),c(t=>e.get(t)),l(({response:t})=>t.comments))}static readProfile(t){return this.apiUrl.pipe(l(e=>`${e}/profiles/${t}`),c(t=>e.get(t)),l(({response:t})=>t.profile))}static readTags(){return this.apiUrl.pipe(l(t=>`${t}/tags`),c(t=>e.get(t)),l(({response:t})=>t.tags))}static removeArticle(t){return this.apiUrl.pipe(l(e=>`${e}/articles/${t.slug}`),c(t=>e.delete(t)),l(({response:t})=>t))}static removeComment(t,s){return this.apiUrl.pipe(l(e=>`${e}/articles/${t.slug}/comments/${s.id}`),c(t=>e.delete(t)),l(({response:t})=>t))}static updateArticle(t){return this.apiUrl.pipe(c(s=>e.request({body:{article:t},method:t.slug?"PUT":"POST",url:`${s}/articles`+(t.slug?`/${t.slug}`:"")})),l(({response:t})=>t.article))}static updateComment(t,s){return this.apiUrl.pipe(c(i=>e.request({body:{comment:s},method:"POST",url:`${i}/articles/${t.slug}/comments`})),l(({response:t})=>t.comment))}static updateFollow(t){return this.apiUrl.pipe(c(s=>e.request({method:t.following?"DELETE":"POST",url:`${s}/profiles/${t.username}/follow`})),l(({response:t})=>t.profile))}static updateLike(t){return this.apiUrl.pipe(c(s=>e.request({method:t.favorited?"DELETE":"POST",url:`${s}/articles/${t.slug}/favorite`})),l(({response:t})=>t.article))}constructor(){throw new TypeError("Endpoint.constructor")}}var j,T;let E=(T=j=class extends y{constructor(...t){super(...t),this.bio=void 0,this.email=void 0,this.image=void 0,this.token=void 0,this.username=void 0}async login(t,e){const{fetch:s,state:i}=sgrud.state.effects,r=await i("io.github.sgrud.state.config"),o=await s(`${r.apiUrl}/users/login`,{method:"POST",headers:{accept:"application/json","content-type":"application/json"},body:JSON.stringify({user:{email:t,password:e}})});if(!o.ok)throw await o.json();const{user:a}=await o.json();return Object.assign({},this,a)}async logout(){return Object.assign({},this,{bio:void 0,email:void 0,image:void 0,password:void 0,token:void 0,username:void 0})}async register(t,e,s){const{fetch:i,state:r}=sgrud.state.effects,o=await r("io.github.sgrud.state.config"),a=await i(`${o.apiUrl}/users`,{method:"POST",headers:{accept:"application/json","content-type":"application/json"},body:JSON.stringify({user:{email:t,username:e,password:s}})});if(!a.ok)throw await a.json();const{user:n}=await a.json();return Object.assign({},this,n)}async update(t){const{fetch:e,state:s}=sgrud.state.effects,i=await s("io.github.sgrud.state.config"),r=await e(`${i.apiUrl}/user`,{method:"PUT",headers:{accept:"application/json",authorization:`Token ${this.token}`,"content-type":"application/json"},body:JSON.stringify({user:t})});if(!r.ok)throw await r.json();const{user:o}=await r.json();return Object.assign({},this,o)}},j.handle="io.github.sgrud.state.user",j);E=T=f([v(T.handle,{bio:void 0,email:void 0,image:void 0,token:void 0,username:void 0})],E);let O=class extends(s("sgrud.core.Proxy")){constructor(...t){super(...t),this.configStore=void 0,this.userStore=void 0}handle(t,e){return u($,d(0)).pipe(c(s=>s instanceof $?h({configState:n(this.configStore).pipe(p()),userState:n(this.userStore).pipe(p())}).pipe(c(({configState:s,userState:r})=>(t.url.startsWith(s.apiUrl)&&r.token&&i(t,{headers:{authorization:`Token ${r.token}`}}),e.handle(t)))):e.handle(t)))}};f([r(()=>U)],O.prototype,"configStore",void 0),f([r(()=>E)],O.prototype,"userStore",void 0),O=f([o()],O);let k=class extends a{constructor(){super(),document.documentElement.style.transition="250ms filter",n(this).subscribe(({length:t})=>{document.documentElement.style.filter=`grayscale(${t?1:0})`,document.documentElement.style.pointerEvents=t?"none":"auto"})}};k=f([o([],a)],k);let P=class extends(s("sgrud.shell.Queue")){constructor(...t){super(...t),this.element=void 0}handle(t,e,s){var i;const{element:r=document.documentElement}=this;return(i=r.style).transition||(i.transition="opacity 100ms"),r.style.opacity="0",d(100).pipe(c(()=>s.handle(e).pipe(m(100))),g(()=>r.style.opacity="1"))}};P=f([o()],P);export{U as ConfigStore,S as Endpoint,k as FadeProxy,P as FadeQueue,O as UserProxy,E as UserStore};
//# sourceMappingURL=index.modern.js.map
